#!/usr/bin/env php
<?php
/* Copyright 2018 Romain "Artefact2" Dal Maso <artefact2@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

ini_set('memory_limit', -1);
assert_options(ASSERT_BAIL, 1);

if($argc !== 2) {
	fprintf(STDERR, "Usage: %s book.tsv\n", $argv[0]);
	die(1);
}



$book = [];
$bf = fopen($argv[1], 'rb');
assert($bf !== false);
while($l = fgets($bf)) {
	list($w, $d, $l, $pgn) = explode("\t", substr($l, 0, -1));
	$book[$pgn] = [ (int)$w, (int)$d, (int)$l ];
}
fclose($bf);
printf("Loaded %d positions from book.\n", count($book));


function gumble(string $cmd, bool $expectresult = true): ?string {
	static $proc = null;
	static $pipes = null;

	if($proc === null) {
		$proc = proc_open(__DIR__.'/../../puzzlegen/build/gumble/src/gumble', [ 0 => [ 'pipe', 'r' ], 1 => [ 'pipe', 'w' ] ], $pipes);
		assert($proc !== false);
	}

	fwrite($pipes[0], $cmd."\n");
	if($expectresult === false) return null;

	$line = fgets($pipes[1]);
	assert($line !== false);
	$line = explode(' ', substr($line, 0, -1), 3);
	assert($line[0] === 'info' && $line[1] === explode(' ', $cmd, 2)[0]);
	return $line[2];
}

function shortfen(string $fen): string {
	$fen = explode(' ', $fen, 5);
	array_pop($fen);
	return implode(' ', $fen);
}

echo "Enter moves in short or long algebraic notation. Use '..' to undo the previous move. Use ^C or q to exit.\n";
$lanmoves = '';
while(true) {
	gumble('position startpos moves '.$lanmoves, false);

	$fen = shortfen(gumble('fen'));
	$lans = explode(' ', gumble('moves'));

	$sans = [];
	foreach($lans as $l) {
		$sans[$l] = gumble('san '.$l);
	}

	$positions = [];
	foreach($lans as $l) {
		gumble('position startpos moves '.$lanmoves.' '.$l, false);
		$nf = shortfen(gumble('fen'));
		if(!isset($book[$nf])) continue;
		$positions[$l] = $book[$nf];
	}

	uasort($positions, function(array $a, array $b): int {
			return $b[0] + $b[1] + $b[2] - $a[0] - $a[1] - $a[2];
		});

	echo $fen, "\n";
	foreach($positions as $l => $wdl) {
		printf(
			"%10s %9d %6.2f %6.2f/%6.2f/%6.2f\n",
			$sans[$l],
			$wdl[0] + $wdl[1] + $wdl[2],
			100. * ($wdl[0] + $wdl[1] + $wdl[2]) / ($book[$fen][0] + $book[$fen][1] + $book[$fen][2]),
			100. * $wdl[0] / ($wdl[0] + $wdl[1] + $wdl[2]),
			100. * $wdl[1] / ($wdl[0] + $wdl[1] + $wdl[2]),
			100. * $wdl[2] / ($wdl[0] + $wdl[1] + $wdl[2])
		);
	}

	while(true) {
		echo '> ';
		$input = trim(fgets(STDIN));
		if(feof(STDIN) || $input === 'q') {
			die(0);
		}
		if($input === '..') {
			$lml = strlen($lanmoves);
			$trim = 1;
			while($lml > 0 && $lanmoves[$lml - 1] !== ' ') {
				++$trim;
				--$lml;
			}
			$lanmoves = substr($lanmoves, 0, -$trim);
			break;
		}
		if(isset($sans[$input])) {
			$lanmoves .= ' '.$input;
			break;
		}
		foreach($sans as $l => $s) {
			if($s === $input) {
				$lanmoves .= ' '.$l;
				break 2;
			}
		}

		if($input !== '') {
			printf("I did not understand that command: %s.\n", json_encode($input));
		}
	}
}