#!/usr/bin/env php
<?php
/* Copyright 2018 Romain "Artefact2" Dal Maso <artefact2@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require __DIR__.'/config.php';

if($argc < 2) {
	fprintf(STDERR, "Usage: %s <jsonstr1> <jsonstr2> <jsonstr3>...\n", $argv[0]);
	die(1);
}

array_shift($argv);

$eproc = proc_open(ENGINE, [ 0 => [ 'pipe', 'r' ], 1 => [ 'pipe', 'w' ] ], $epipes);
assert($eproc !== false);
fputs($epipes[0], "uci\n");

$gproc = proc_open(__DIR__.'/../gumble/build/src/gumble', [ 0 => [ 'pipe', 'r' ], 1 => [ 'pipe', 'w' ] ], $gpipes);
assert($gproc !== false);

function lan(array $gpipes, string $lanmoves, string $san): string {
	fprintf($gpipes[0], "position startpos moves %s\nlan %s\n", $lanmoves, $san);
	fflush($gpipes[0]);
	while($line = fgets($gpipes[1])) {
		if(preg_match('%^info lan (?<ret>.+)$%', $line, $m)) return $m['ret'];
	}
	assert(0);
}

function fen(array $gpipes, string $lanmoves): string {
	fprintf($gpipes[0], "position startpos moves %s\nfen\n", $lanmoves);
	fflush($gpipes[0]);
	while($line = fgets($gpipes[1])) {
		if(preg_match('%^info fen (?<ret>.+)$%', $line, $m)) return $m['ret'];
	}
	assert(0);
}

function evaluate_position(array $epipes, string $lanmoves, int $branches, &$evals): string {
	fprintf($epipes[0], "setoption name MultiPV value %d\n", $branches);
	fprintf($epipes[0], "position startpos moves %s\ngo %s\n", $lanmoves, ENGINE_LIMITER);
	fflush($epipes[0]);

	$evals = [];

	while($line = fgets($epipes[1])) {
		if(preg_match('%^bestmove\s+(?<lan>([a-h][1-8]){2}[qrbn]?)(\s|$)%', $line, $match)) {
			return $match['lan'];
		}

		if(!preg_match('%^info\s%', $line)) continue;
		$mpv = preg_match('%\smultipv\s+(?<mpv>[0-9]+)(\s|$)%', $line, $match) ? (int)$match['mpv'] : 1;
		/* XXX: also parse "score mate N" */
		if(!preg_match('%\sscore\s+cp\s+(?<eval>-?[0-9]+)(\s|$)%', $line, $me)) continue;
		if(!preg_match('%\spv\s+(?<move>([a-h][1-8]){2}[qrbn]?)(\s|$)%', $line, $mp)) continue;
		$evals[$mpv] = [ (int)$me['eval'], $mp['move'] ];
	}
	assert(0);
}

function generate_puzzle(array $epipes, string $lanmoves, ?string $bestlan = null, ?array $evals = null): ?array {
	if($evals === null || $bestlan === null) {
		$bestlan = evaluate_position($epipes, $lanmoves, MAX_VARIATIONS + 1, $evals);
	}

	$c = count($evals);
	if($c === 0) {
		/* check/stale mate */
		return null;
	}

	if($c === 1) {
		/* XXX: some tactics have forced moves after the start */
		/* forced move, no tactics to consider here */
		return null;
	}

	usort($evals, function(array $a, array $b) {
		return $b[0] - $a[0];
	});

	if($evals[0][0] < -POSITION_EVAL_CUTOFF || $evals[$c - 1][0] > POSITION_EVAL_CUTOFF) {
		/* clearly lost or won position */
		return null;
	}

	$stop = 0;
	for($i = 1; $i < $c; ++$i) {
		if($evals[0][0] - $evals[$i][0] <= VARIATIONS_MAX_DIFF) continue;
		if($evals[0][0] - $evals[$i][0] >= BEST_MOVE_EVAL_CUTOFF) {
			$stop = $i;
		}
		break;
	}

	if($stop === 0) {
		/* Puzzle is over, there's not one set of moves clearly better than others */
		return null;
	}

	$ret = [];
	for($i = 0; $i < $stop; ++$i) {
		$lan = $evals[$i][1];
		$cont = $lanmoves.' '.$lan;
		$bestreply = evaluate_position($epipes, $cont, 1, $replyevals);

		if($bestreply === "(none)") {
			/* XXX: is this UCI standard ? */
			/* Game over, check/stale mate */
			$ret[$lan] = null;
			continue;
		}

		if(($next = generate_puzzle($epipes, $cont.' '.$bestreply)) !== null) {
			$ret[$lan] = [ $lan, $next ];
			continue;
		}

		$ret[$lan] = null;
	}
	return $ret;
}

while($json = array_shift($argv)) {
	fputs($epipes[0], "ucinewgame\n");
	fflush($epipes[0]);

	$lanmoves = '';
	foreach(json_decode($json, true) as $ply => $san) {
		$lan = lan($gpipes, $lanmoves, $san);
		$lanmoves .= ' '.$lan;

		if($ply < MIN_PLY_CUTOFF) continue;
		if(($puz = generate_puzzle($epipes, $lanmoves)) === null) continue;
		echo json_encode([
			fen($gpipes, substr($lanmoves, 0, -strlen($lan) - 1)),
			$lan,
			$puz
		]), "\n";
	}
}

fputs($epipes[0], "quit\n");
fputs($gpipes[0], "quit\n");
